// Code generated by coreGen. DO NOT EDIT.

package react

import "github.com/gopherjs/gopherjs/js"

// AElem is the React element definition corresponding to the HTML <a> element
type AElem struct {
	Element
}

func (a *AElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type AProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	Href                    string
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
	Target                  string
	Title                   string
}

// A creates a new instance of a <a> element with the provided props and
// children
func A(props *AProps, children ...Element) *AElem {
	type _AProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		Href                    string              `js:"href"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
		Target                  string              `js:"target"`
		Title                   string              `js:"title"`
	}

	rprops := &_AProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		rprops.Href = props.Href

		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
		rprops.Target = props.Target

		rprops.Title = props.Title
	}

	return &AElem{
		Element: createElement("a", rprops, children...),
	}
}

// BrElem is the React element definition corresponding to the HTML <br> element
type BrElem struct {
	Element
}

func (a *BrElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type BrProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Br creates a new instance of a <br> element with the provided props and
// children
func Br(props *BrProps, children ...Element) *BrElem {
	type _BrProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_BrProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &BrElem{
		Element: createElement("br", rprops, children...),
	}
}

// ButtonElem is the React element definition corresponding to the HTML <button> element
type ButtonElem struct {
	Element
}

func (a *ButtonElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type ButtonProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
	Type                    string
}

// Button creates a new instance of a <button> element with the provided props and
// children
func Button(props *ButtonProps, children ...Element) *ButtonElem {
	type _ButtonProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
		Type                    string              `js:"type"`
	}

	rprops := &_ButtonProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
		rprops.Type = props.Type
	}

	return &ButtonElem{
		Element: createElement("button", rprops, children...),
	}
}

// CodeElem is the React element definition corresponding to the HTML <code> element
type CodeElem struct {
	Element
}

func (a *CodeElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type CodeProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Code creates a new instance of a <code> element with the provided props and
// children
func Code(props *CodeProps, children ...Element) *CodeElem {
	type _CodeProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_CodeProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &CodeElem{
		Element: createElement("code", rprops, children...),
	}
}

// DivElem is the React element definition corresponding to the HTML <div> element
type DivElem struct {
	Element
}

func (a *DivElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type DivProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Div creates a new instance of a <div> element with the provided props and
// children
func Div(props *DivProps, children ...Element) *DivElem {
	type _DivProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_DivProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &DivElem{
		Element: createElement("div", rprops, children...),
	}
}

// FooterElem is the React element definition corresponding to the HTML <footer> element
type FooterElem struct {
	Element
}

func (a *FooterElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type FooterProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Footer creates a new instance of a <footer> element with the provided props and
// children
func Footer(props *FooterProps, children ...Element) *FooterElem {
	type _FooterProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_FooterProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &FooterElem{
		Element: createElement("footer", rprops, children...),
	}
}

// FormElem is the React element definition corresponding to the HTML <form> element
type FormElem struct {
	Element
}

func (a *FormElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type FormProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Form creates a new instance of a <form> element with the provided props and
// children
func Form(props *FormProps, children ...Element) *FormElem {
	type _FormProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_FormProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &FormElem{
		Element: createElement("form", rprops, children...),
	}
}

// H1Elem is the React element definition corresponding to the HTML <h1> element
type H1Elem struct {
	Element
}

func (a *H1Elem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type H1Props struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// H1 creates a new instance of a <h1> element with the provided props and
// children
func H1(props *H1Props, children ...Element) *H1Elem {
	type _H1Props struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_H1Props{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &H1Elem{
		Element: createElement("h1", rprops, children...),
	}
}

// H2Elem is the React element definition corresponding to the HTML <h2> element
type H2Elem struct {
	Element
}

func (a *H2Elem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type H2Props struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// H2 creates a new instance of a <h2> element with the provided props and
// children
func H2(props *H2Props, children ...Element) *H2Elem {
	type _H2Props struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_H2Props{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &H2Elem{
		Element: createElement("h2", rprops, children...),
	}
}

// H3Elem is the React element definition corresponding to the HTML <h3> element
type H3Elem struct {
	Element
}

func (a *H3Elem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type H3Props struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// H3 creates a new instance of a <h3> element with the provided props and
// children
func H3(props *H3Props, children ...Element) *H3Elem {
	type _H3Props struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_H3Props{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &H3Elem{
		Element: createElement("h3", rprops, children...),
	}
}

// H4Elem is the React element definition corresponding to the HTML <h4> element
type H4Elem struct {
	Element
}

func (a *H4Elem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type H4Props struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// H4 creates a new instance of a <h4> element with the provided props and
// children
func H4(props *H4Props, children ...Element) *H4Elem {
	type _H4Props struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_H4Props{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &H4Elem{
		Element: createElement("h4", rprops, children...),
	}
}

// H5Elem is the React element definition corresponding to the HTML <h5> element
type H5Elem struct {
	Element
}

func (a *H5Elem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type H5Props struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// H5 creates a new instance of a <h5> element with the provided props and
// children
func H5(props *H5Props, children ...Element) *H5Elem {
	type _H5Props struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_H5Props{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &H5Elem{
		Element: createElement("h5", rprops, children...),
	}
}

// HrElem is the React element definition corresponding to the HTML <hr> element
type HrElem struct {
	Element
}

func (a *HrElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type HrProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Hr creates a new instance of a <hr> element with the provided props and
// children
func Hr(props *HrProps) *HrElem {
	type _HrProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_HrProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &HrElem{
		Element: createElement("hr", rprops),
	}
}

// IElem is the React element definition corresponding to the HTML <i> element
type IElem struct {
	Element
}

func (a *IElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type IProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// I creates a new instance of a <i> element with the provided props and
// children
func I(props *IProps, children ...Element) *IElem {
	type _IProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_IProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &IElem{
		Element: createElement("i", rprops, children...),
	}
}

// IFrameElem is the React element definition corresponding to the HTML <iframe> element
type IFrameElem struct {
	Element
}

func (a *IFrameElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type IFrameProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	SrcDoc                  string
	Style                   *CSS
}

// IFrame creates a new instance of a <iframe> element with the provided props and
// children
func IFrame(props *IFrameProps, children ...Element) *IFrameElem {
	type _IFrameProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		SrcDoc                  string              `js:"srcDoc"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_IFrameProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		rprops.SrcDoc = props.SrcDoc

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &IFrameElem{
		Element: createElement("iframe", rprops, children...),
	}
}

// ImgElem is the React element definition corresponding to the HTML <img> element
type ImgElem struct {
	Element
}

func (a *ImgElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type ImgProps struct {
	Alt                     string
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Src                     string
	Style                   *CSS
}

// Img creates a new instance of a <img> element with the provided props and
// children
func Img(props *ImgProps, children ...Element) *ImgElem {
	type _ImgProps struct {
		o                       *js.Object
		Alt                     string              `js:"alt"`
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Src                     string              `js:"src"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_ImgProps{
		o: object.New(),
	}

	if props != nil {
		rprops.Alt = props.Alt

		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		rprops.Src = props.Src

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &ImgElem{
		Element: createElement("img", rprops, children...),
	}
}

// InputElem is the React element definition corresponding to the HTML <input> element
type InputElem struct {
	Element
}

func (a *InputElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type InputProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Placeholder             string
	Ref                     Ref
	Role                    string
	Style                   *CSS
	Type                    string
	Value                   string
}

// Input creates a new instance of a <input> element with the provided props and
// children
func Input(props *InputProps, children ...Element) *InputElem {
	type _InputProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Placeholder             string              `js:"placeholder"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
		Type                    string              `js:"type"`
		Value                   string              `js:"value"`
	}

	rprops := &_InputProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		rprops.Placeholder = props.Placeholder

		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
		rprops.Type = props.Type

		rprops.Value = props.Value
	}

	return &InputElem{
		Element: createElement("input", rprops, children...),
	}
}

// LabelElem is the React element definition corresponding to the HTML <label> element
type LabelElem struct {
	Element
}

func (a *LabelElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type LabelProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	For                     string
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Label creates a new instance of a <label> element with the provided props and
// children
func Label(props *LabelProps, children ...Element) *LabelElem {
	type _LabelProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		For                     string              `js:"htmlFor"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_LabelProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		rprops.For = props.For

		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &LabelElem{
		Element: createElement("label", rprops, children...),
	}
}

// LiElem is the React element definition corresponding to the HTML <li> element
type LiElem struct {
	Element
}

func (a *LiElem) coreReactElement() {}

func (l *LiElem) RendersLi(*LiElem) {}

// _AProps defines the properties for the <a> element
type LiProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Li creates a new instance of a <li> element with the provided props and
// children
func Li(props *LiProps, children ...Element) *LiElem {
	type _LiProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_LiProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &LiElem{
		Element: createElement("li", rprops, children...),
	}
}

// NavElem is the React element definition corresponding to the HTML <nav> element
type NavElem struct {
	Element
}

func (a *NavElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type NavProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Nav creates a new instance of a <nav> element with the provided props and
// children
func Nav(props *NavProps, children ...Element) *NavElem {
	type _NavProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_NavProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &NavElem{
		Element: createElement("nav", rprops, children...),
	}
}

// OptionElem is the React element definition corresponding to the HTML <option> element
type OptionElem struct {
	Element
}

func (a *OptionElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type OptionProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
	Value                   string
}

// Option creates a new instance of a <option> element with the provided props and
// children
func Option(props *OptionProps, children ...Element) *OptionElem {
	type _OptionProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
		Value                   string              `js:"value"`
	}

	rprops := &_OptionProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
		rprops.Value = props.Value
	}

	return &OptionElem{
		Element: createElement("option", rprops, children...),
	}
}

// PElem is the React element definition corresponding to the HTML <p> element
type PElem struct {
	Element
}

func (a *PElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type PProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// P creates a new instance of a <p> element with the provided props and
// children
func P(props *PProps, children ...Element) *PElem {
	type _PProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_PProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &PElem{
		Element: createElement("p", rprops, children...),
	}
}

// PreElem is the React element definition corresponding to the HTML <pre> element
type PreElem struct {
	Element
}

func (a *PreElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type PreProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Pre creates a new instance of a <pre> element with the provided props and
// children
func Pre(props *PreProps, children ...Element) *PreElem {
	type _PreProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_PreProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &PreElem{
		Element: createElement("pre", rprops, children...),
	}
}

// SelectElem is the React element definition corresponding to the HTML <select> element
type SelectElem struct {
	Element
}

func (a *SelectElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type SelectProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
	Value                   string
}

// Select creates a new instance of a <select> element with the provided props and
// children
func Select(props *SelectProps, children ...*OptionElem) *SelectElem {
	type _SelectProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
		Value                   string              `js:"value"`
	}

	var elems []Element
	for _, v := range children {
		elems = append(elems, v)
	}

	rprops := &_SelectProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
		rprops.Value = props.Value
	}

	return &SelectElem{
		Element: createElement("select", rprops, elems...),
	}
}

// SpanElem is the React element definition corresponding to the HTML <span> element
type SpanElem struct {
	Element
}

func (a *SpanElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type SpanProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Span creates a new instance of a <span> element with the provided props and
// children
func Span(props *SpanProps, children ...Element) *SpanElem {
	type _SpanProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_SpanProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &SpanElem{
		Element: createElement("span", rprops, children...),
	}
}

// StrikeElem is the React element definition corresponding to the HTML <strike> element
type StrikeElem struct {
	Element
}

func (a *StrikeElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type StrikeProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Strike creates a new instance of a <strike> element with the provided props and
// children
func Strike(props *StrikeProps, children ...Element) *StrikeElem {
	type _StrikeProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_StrikeProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &StrikeElem{
		Element: createElement("strike", rprops, children...),
	}
}

// TableElem is the React element definition corresponding to the HTML <table> element
type TableElem struct {
	Element
}

func (a *TableElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type TableProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Table creates a new instance of a <table> element with the provided props and
// children
func Table(props *TableProps, children ...Element) *TableElem {
	type _TableProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_TableProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &TableElem{
		Element: createElement("table", rprops, children...),
	}
}

// TextAreaElem is the React element definition corresponding to the HTML <textarea> element
type TextAreaElem struct {
	Element
}

func (a *TextAreaElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type TextAreaProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Placeholder             string
	Ref                     Ref
	Role                    string
	Style                   *CSS
	Value                   string
}

// TextArea creates a new instance of a <textarea> element with the provided props and
// children
func TextArea(props *TextAreaProps, children ...Element) *TextAreaElem {
	type _TextAreaProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Placeholder             string              `js:"placeholder"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
		Value                   string              `js:"value"`
	}

	rprops := &_TextAreaProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		rprops.Placeholder = props.Placeholder

		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
		rprops.Value = props.Value
	}

	return &TextAreaElem{
		Element: createElement("textarea", rprops, children...),
	}
}

// UlElem is the React element definition corresponding to the HTML <ul> element
type UlElem struct {
	Element
}

func (a *UlElem) coreReactElement() {}

// _AProps defines the properties for the <a> element
type UlProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Ul creates a new instance of a <ul> element with the provided props and
// children
func Ul(props *UlProps, children ...RendersLi) *UlElem {
	type _UlProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	var elems []Element
	for _, v := range children {
		elems = append(elems, v)
	}

	rprops := &_UlProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &UlElem{
		Element: createElement("ul", rprops, elems...),
	}
}
